import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { SpriteSheet } from 'gtp';
import { Maze } from './Maze';
import { PacmanGame } from './PacmanGame';

const mockSpriteSheet = {
    drawByIndex: () => {},
    drawScaled2: vi.fn(),
} as unknown as SpriteSheet;

describe('Maze', () => {
    let game: PacmanGame;

    beforeEach(() => {
        game = new PacmanGame();
        game.assets.set('mapTiles', mockSpriteSheet);
        game.assets.set('font', mockSpriteSheet);
        game.assets.set('sprites', mockSpriteSheet);
    });

    afterEach(() => {
        vi.restoreAllMocks();
    });

    describe('checkForDot', () => {
        const levelData = [
            [ 0x00, 0xfe, 0xff, 0xff ],
        ];
        let maze: Maze;

        beforeEach(() => {
            maze = new Maze(game, levelData);
        });

        describe('big dots', () => {
            it('returns 50 points', () => {
                expect(maze.checkForDot(0, 1)).toBe(50);
            });

            it('plays the chomp sound', () => {
                const playChompSoundSpy = vi.spyOn(game, 'playChompSound');
                maze.checkForDot(0, 1);
                expect(playChompSoundSpy).toHaveBeenCalled();
            });

            it('makes the ghosts blue', () => {
                const makeGhostsBlueSpy = vi.spyOn(game, 'makeGhostsBlue');
                maze.checkForDot(0, 1);
                expect(makeGhostsBlueSpy).toHaveBeenCalled();
            });
        });

        describe('small dots', () => {
            it('returns 10 points', () => {
                expect(maze.checkForDot(0, 2)).toBe(10);
            });

            it('plays the chomp sound', () => {
                const playChompSoundSpy = vi.spyOn(game, 'playChompSound');
                maze.checkForDot(0, 2);
                expect(playChompSoundSpy).toHaveBeenCalled();
            });

            it('does not make the ghosts blue', () => {
                const makeGhostsBlueSpy = vi.spyOn(game, 'makeGhostsBlue');
                maze.checkForDot(0, 2);
                expect(makeGhostsBlueSpy).not.toHaveBeenCalled();
            });
        });

        describe('no dot', () => {
            it('returns 0 points', () => {
                expect(maze.checkForDot(0, 0)).toBe(0);
            });

            it('does not play the chomp sound', () => {
                const playChompSoundSpy = vi.spyOn(game, 'playChompSound');
                maze.checkForDot(0, 0);
                expect(playChompSoundSpy).not.toHaveBeenCalled();
            });

            it('does not make the ghosts blue', () => {
                const makeGhostsBlueSpy = vi.spyOn(game, 'makeGhostsBlue');
                maze.checkForDot(0, 0);
                expect(makeGhostsBlueSpy).not.toHaveBeenCalled();
            });
        });
    });

    it('returns the expected value for FRUIT_DOT_COUNT', () => {
        expect(Maze.FRUIT_DOT_COUNT).toBe(64);
    });

    describe('getPathBreadthFirst', () => {
        describe('happy path and edge case tests', () => {
            const levelData = [
                [ 0x02, 0x02, 0x02, 0x02 ],
                [ 0x02, 0x00, 0x00, 0x02 ],
                [ 0x02, 0x02, 0x02, 0x02 ],
            ];
            let maze: Maze;

            beforeEach(() => {
                maze = new Maze(game, levelData);
            });

            it('returns a path to an adjacent node', () => {
                const path = maze.getPathBreadthFirst(1, 1, 1, 2);
                if (!path) {
                    throw new Error('path should not be null');
                }
                expect(path.row).toEqual(1);
                expect(path.col).toEqual(2);
            });

            it('returns an error for an invalid destination', () => {
                expect(() => maze.getPathBreadthFirst(1, 1, 3, 3)).toThrow('No path found from (1, 1) to (3, 3)');
            });

            it('returns null for the same start and end node', () => {
                const path = maze.getPathBreadthFirst(1, 1, 1, 1);
                expect(path).toBeNull();
            });
        });

        describe('when the path is not straight', () => {
            const levelData = [
                [ 0x02, 0x02, 0x02, 0x02, 0x02, 0x02 ],
                [ 0x02, 0x00, 0x02, 0x02, 0x00, 0x02 ],
                [ 0x02, 0x00, 0x00, 0x00, 0x00, 0x02 ],
                [ 0x02, 0x02, 0x02, 0x02, 0x02, 0x02 ],
            ];
            let maze: Maze;

            beforeEach(() => {
                maze = new Maze(game, levelData);
            });

            it('returns the expected path', () => {
                // Path should be: (1, 1) -> (2, 1) -> (2, 2) -> (2, 3) -> (2, 4) -> (1, 4)

                // Step 1
                const path = maze.getPathBreadthFirst(1, 1, 1, 4);
                if (!path) {
                    throw new Error('path should not be null');
                }
                expect(path.row).toEqual(2);
                expect(path.col).toEqual(1);

                // Step 2
                const nextPath = maze.getPathBreadthFirst(2, 1, 1, 4);
                if (!nextPath) {
                    throw new Error('nextPath should not be null');
                }
                expect(nextPath.row).toEqual(2);
                expect(nextPath.col).toEqual(2);

                // Step 3
                const nextPath2 = maze.getPathBreadthFirst(2, 2, 2, 3);
                if (!nextPath2) {
                    throw new Error('nextPath2 should not be null');
                }
                expect(nextPath2.row).toEqual(2);
                expect(nextPath2.col).toEqual(3);

                // Step 4
                const nextPath3 = maze.getPathBreadthFirst(2, 3, 2, 4);
                if (!nextPath3) {
                    throw new Error('nextPath3 should not be null');
                }
                expect(nextPath3.row).toEqual(2);
                expect(nextPath3.col).toEqual(4);

                // Step 5
                const finalPath = maze.getPathBreadthFirst(2, 4, 1, 4);
                if (!finalPath) {
                    throw new Error('finalPath should not be null');
                }
                expect(finalPath.row).toEqual(1);
                expect(finalPath.col).toEqual(4);

                // Another call returns null
                const anotherPath = maze.getPathBreadthFirst(1, 4, 1, 4);
                expect(anotherPath).toBeNull();
            });
        });
    });

    describe('isClearShotColumn', () => {
        const levelData = [
            [ 0x02, 0x02, 0x02, 0x02 ],
            [ 0x02, 0x00, 0x00, 0x02 ],
            [ 0x02, 0x00, 0x00, 0x02 ],
            [ 0x02, 0x00, 0x02, 0x02 ],
            [ 0x02, 0x00, 0x00, 0x02 ],
            [ 0x02, 0x02, 0x02, 0x02 ],
        ];
        let maze: Maze;

        beforeEach(() => {
            maze = new Maze(game, levelData);
        });

        it('returns true for a clear shot column', () => {
            expect(maze.isClearShotColumn(1, 1, 4)).toBe(true);
        });

        it('returns false if nodes in between are not traversable', () => {
            expect(maze.isClearShotColumn(2, 1, 4)).toBe(false);
        });
    });

    describe('isClearShotRow', () => {
        const levelData = [
            [ 0x02, 0x02, 0x02, 0x02, 0x02, 0x02 ],
            [ 0x02, 0x00, 0x00, 0x00, 0x00, 0x02 ],
            [ 0x02, 0x00, 0x00, 0x02, 0x00, 0x02 ],
            [ 0x02, 0x02, 0x02, 0x02, 0x02, 0x02 ],
        ];
        let maze: Maze;

        beforeEach(() => {
            maze = new Maze(game, levelData);
        });

        it('returns true for a clear shot row', () => {
            expect(maze.isClearShotRow(1, 1, 4)).toBe(true);
        });

        it('returns false if nodes in between are not traversable', () => {
            expect(maze.isClearShotRow(2, 1, 4)).toBe(false);
        });
    });

    describe('isWalkable', () => {
        const levelData = [
            [ 0x00, 0x01, 0xef, 0xf0, 0xfe, 0xff ],
        ];
        let maze: Maze;

        beforeEach(() => {
            maze = new Maze(game, levelData);
        });

        it('returns true and false appropriately', () => {
            expect(maze.isWalkable(0, 0)).toBe(true);
            expect(maze.isWalkable(0, 1)).toBe(false);
            expect(maze.isWalkable(0, 2)).toBe(false);
            expect(maze.isWalkable(0, 3)).toBe(true);
            expect(maze.isWalkable(0, 4)).toBe(true);
            expect(maze.isWalkable(0, 5)).toBe(true);
        });
    });

    describe('render', () => {
        const levelData = [
            [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ],
            [ 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x06 ],
            [ 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c ],
            [ 0x07, 0xff, 0x0d, 0x0e, 0x0e, 0x12, 0xff, 0x0d, 0x0e, 0x0e, 0x0e, 0x12, 0xff, 0x09, 0x0a, 0xff, 0x0d, 0x0e, 0x0e, 0x0e, 0x12, 0xff, 0x0d, 0x0e, 0x0e, 0x12, 0xff, 0x0c ],
            [ 0x07, 0xfe, 0x09, 0x00, 0x00, 0x0a, 0xff, 0x09, 0x00, 0x00, 0x00, 0x0a, 0xff, 0x09, 0x0a, 0xff, 0x09, 0x00, 0x00, 0x00, 0x0a, 0xff, 0x09, 0x00, 0x00, 0x0a, 0xfe, 0x0c ],
            [ 0x07, 0xff, 0x0f, 0x11, 0x11, 0x10, 0xff, 0x0f, 0x11, 0x11, 0x11, 0x10, 0xff, 0x0f, 0x10, 0xff, 0x0f, 0x11, 0x11, 0x11, 0x10, 0xff, 0x0f, 0x11, 0x11, 0x10, 0xff, 0x0c ],
            [ 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c ],
            [ 0x07, 0xff, 0x0d, 0x0e, 0x0e, 0x12, 0xff, 0x0d, 0x12, 0xff, 0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x12, 0xff, 0x0d, 0x12, 0xff, 0x0d, 0x0e, 0x0e, 0x12, 0xff, 0x0c ],
            [ 0x07, 0xff, 0x0f, 0x11, 0x11, 0x10, 0xff, 0x09, 0x0a, 0xff, 0x0f, 0x11, 0x11, 0x14, 0x1d, 0x11, 0x11, 0x10, 0xff, 0x09, 0x0a, 0xff, 0x0f, 0x11, 0x11, 0x10, 0xff, 0x0c ],
            [ 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c ],
            [ 0x13, 0x17, 0x17, 0x17, 0x17, 0x12, 0xff, 0x09, 0x05, 0x0e, 0x0e, 0x12, 0x00, 0x09, 0x0a, 0x00, 0x0d, 0x0e, 0x0e, 0x1a, 0x0a, 0xff, 0x0d, 0x17, 0x17, 0x17, 0x17, 0x18 ],
            [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x09, 0x1d, 0x11, 0x11, 0x10, 0x00, 0x0f, 0x10, 0x00, 0x0f, 0x11, 0x11, 0x14, 0x0a, 0xff, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00 ],
            [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x09, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0xff, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00 ],
            [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x09, 0x0a, 0x00, 0x19, 0x17, 0x1b, 0x08, 0x08, 0x1c, 0x17, 0x1e, 0x00, 0x09, 0x0a, 0xff, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00 ],
            [ 0x02, 0x02, 0x02, 0x02, 0x02, 0x10, 0xff, 0x0f, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x0f, 0x10, 0xff, 0x0f, 0x02, 0x02, 0x02, 0x02, 0x02 ],
            [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ],
            [ 0x17, 0x17, 0x17, 0x17, 0x17, 0x12, 0xff, 0x0d, 0x12, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x0d, 0x12, 0xff, 0x0d, 0x17, 0x17, 0x17, 0x17, 0x17 ],
            [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x09, 0x0a, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x24, 0x00, 0x09, 0x0a, 0xff, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00 ],
            [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x09, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0xff, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00 ],
            [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x09, 0x0a, 0x00, 0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x12, 0x00, 0x09, 0x0a, 0xff, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00 ],
            [ 0x01, 0x02, 0x02, 0x02, 0x02, 0x10, 0xff, 0x0f, 0x10, 0x00, 0x0f, 0x11, 0x11, 0x14, 0x1d, 0x11, 0x11, 0x10, 0x00, 0x0f, 0x10, 0xff, 0x0f, 0x02, 0x02, 0x02, 0x02, 0x06 ],
            [ 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c ],
            [ 0x07, 0xff, 0x0d, 0x0e, 0x0e, 0x12, 0xff, 0x0d, 0x0e, 0x0e, 0x0e, 0x12, 0xff, 0x09, 0x0a, 0xff, 0x0d, 0x0e, 0x0e, 0x0e, 0x12, 0xff, 0x0d, 0x0e, 0x0e, 0x12, 0xff, 0x0c ],
            [ 0x07, 0xff, 0x0f, 0x11, 0x14, 0x0a, 0xff, 0x0f, 0x11, 0x11, 0x11, 0x10, 0xff, 0x0f, 0x10, 0xff, 0x0f, 0x11, 0x11, 0x11, 0x10, 0xff, 0x09, 0x1d, 0x11, 0x10, 0xff, 0x0c ],
            [ 0x07, 0xfe, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xfe, 0x0c ],
            [ 0x15, 0x0e, 0x12, 0xff, 0x09, 0x0a, 0xff, 0x0d, 0x12, 0xff, 0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x12, 0xff, 0x0d, 0x12, 0xff, 0x09, 0x0a, 0xff, 0x0d, 0x0e, 0x21 ],
            [ 0x16, 0x11, 0x10, 0xff, 0x0f, 0x10, 0xff, 0x09, 0x0a, 0xff, 0x0f, 0x11, 0x11, 0x14, 0x1d, 0x11, 0x11, 0x10, 0xff, 0x09, 0x0a, 0xff, 0x0f, 0x10, 0xff, 0x0f, 0x11, 0x22 ],
            [ 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c ],
            [ 0x07, 0xff, 0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x1a, 0x05, 0x0e, 0x0e, 0x12, 0xff, 0x09, 0x0a, 0xff, 0x0d, 0x0e, 0x0e, 0x1a, 0x05, 0x0e, 0x0e, 0x0e, 0x0e, 0x12, 0xff, 0x0c ],
            [ 0x07, 0xff, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0xff, 0x0f, 0x10, 0xff, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0xff, 0x0c ],
            [ 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c ],
            [ 0x13, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x18 ],
        ];
        let maze: Maze;

        beforeEach(() => {
            maze = new Maze(game, levelData);
        });

        it('renders small dots', () => {
            const drawSmallDotSpy = vi.spyOn(game, 'drawSmallDot');
            maze.render(game.getRenderingContext());
            expect(drawSmallDotSpy).toHaveBeenCalledTimes(240);
        });

        it('renders big dots', () => {
            const drawBigDotSpy = vi.spyOn(game, 'drawBigDot');
            maze.render(game.getRenderingContext());
            expect(drawBigDotSpy).toHaveBeenCalledTimes(4);
        });
    });
});
